using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using TMPro;
using Unity.VisualScripting;
using UnityEditor;
//using System.Numerics;
using UnityEngine;
using UnityEngine.Tilemaps;
using static UnityEditor.PlayerSettings;
//using UnityEditor.Rendering; //used for querying collections and in this case using orderby to extract subset using Guid which is a unique identifyer that we will assign to each value in the hashset then select the guids randomly.


public class CorridorFirstDungeonGeneration : SimpleRandomWalkDungeonGenerator //we extend simplerandomwalk not abstract generator because we are going to use the RunRandomWalk for our corridor generation
{
    [SerializeField]
    private Material waterMaterial;
    [SerializeField]
    private Texture2D seaFoam;
    [SerializeField]
    private Texture2D caustic;
    [SerializeField]
    private Texture2D causticHighlights;
    private Texture2D heightMap, noCaustics; 
    [SerializeField]
    private int corridorLength = 14;
    [SerializeField]
    private int corridorCount = 5;
    [SerializeField]
    private int shoreLength;
    [SerializeField]
    [Range(0.1f, 1)]
    private float roomPercent = 0.8f;
    [SerializeField] private TilemapRenderer waterRenderer;
    [SerializeField] private GameObject exit;
    [SerializeField] private GameObject PlayCanvas;
    [SerializeField] private GameObject EndCanvas;
    [SerializeField] private TMP_Text BioguText;
    [SerializeField] private List<GameObject> Monsters;
    [SerializeField] private PlaceableObject placeable;
    private Dictionary<Vector2Int, HashSet<Vector2Int>> roomMapsDictionairy = new Dictionary<Vector2Int, HashSet<Vector2Int>>(); //key is the start position of each rooms generation and the value is that rooms final hashSet
    private HashSet<Vector2Int> floorOnlyMap, corridorPositions; //Hashsets for each room to be used for dictionairy creation and a hashset of all corridor positions generated by the corridor algorithm.
    public override void RunProceduralGeneration()
    {
        CorridorFirstGeneration();
        createExit();
        SpawnMonsters();
    }
    private void SpawnMonsters()
    {
        DecorandHarvestableGeneration.CreateObjects(floorOnlyMap, Monsters, placeable,
            roomMapsDictionairy, corridorPositions, tilemapVisualizer);
    }
    private void createExit()
    {
        float max = 0.0f;
        Vector2Int key = new Vector2Int();
        foreach (var kvp in roomMapsDictionairy)
        {
            Debug.Log(kvp.Key);
            if (((Vector2Int)kvp.Key).magnitude > max)
            {
                max = ((Vector2Int)kvp.Key).magnitude;
                key = kvp.Key;
            }
        }
        ItemPlacementHelper itemPlacementHelper = new ItemPlacementHelper(roomMapsDictionairy[key], roomMapsDictionairy[key]);
        Vector2Int size = new Vector2Int(1, 1);
        Vector2Int exitLocation = new Vector2Int(0, 0);
        try
        {
            itemPlacementHelper.GetItemPlacementPosition(PlacementType.OpenSpace, 5, size, true);
            exitLocation = (Vector2Int.RoundToInt(itemPlacementHelper.GetItemPlacementPosition(PlacementType.OpenSpace, 5, size, true).Value));
            Vector2Int.RoundToInt(itemPlacementHelper.GetItemPlacementPosition(PlacementType.OpenSpace, 5, size, true).Value);
        }
        catch (System.Exception)
        {
            Debug.Log("No More Room Left to Place items in this room");
        }
        Vector3Int cellPos = new Vector3Int(exitLocation.x, exitLocation.y, 0);
        Vector3 worldPos = tilemapVisualizer.FloorTileMap.CellToWorld(cellPos);
        worldPos.z = -1;
        GameObject newexit = Instantiate(exit, worldPos, Quaternion.identity);
        newexit.GetComponent<Exit>().playCanvas = PlayCanvas;
        newexit.GetComponent<Exit>().endCanvas = EndCanvas;
        newexit.GetComponent<Exit>().bioguEarned = BioguText;
    }
    private void CorridorFirstGeneration()
    {
        HashSet<Vector2Int> floorPositions = new HashSet<Vector2Int>();
        HashSet<Vector2Int> potentialRoomPositions = new HashSet<Vector2Int>();
        roomMapsDictionairy = new Dictionary<Vector2Int, HashSet<Vector2Int>>();
        List<List<Vector2Int>> corridors = CreateCorridors(floorPositions, potentialRoomPositions); //original didnt have potentialroompositions tacked on parameter that does not do anything but is getting the information we need to then create our rooms
        HashSet<Vector2Int> roomPositions = CreateRooms(potentialRoomPositions);
        List<Vector2Int> deadEnds = FindAllDeadEnds(floorPositions);
        CreateRoomsAtDeadEnd(deadEnds, roomPositions); //we pass in roomPositions because maybe createRooms function create a room at the deadend we want to check that
        floorPositions.UnionWith(roomPositions);
        floorOnlyMap = new HashSet<Vector2Int>(floorPositions);
        for (int i = 0; i < corridors.Count; i++)
        {
            //corridors[i] = IncreaseCorridorSizeByOne(corridors[i]);
            corridors[i] = IncreaseCorridorBrush3by3(corridors[i]);
            floorPositions.UnionWith(corridors[i]);

        }
        //tilemapVisualizer.PaintFloorTiles(floorPositions);
        WallGenerator.CreateWalls(floorPositions, tilemapVisualizer);
        //HeightMapTextureMaker.WaterGeneration(floorPositions, waterMaterial, caustic, causticHighlights, seaFoam, shoreLength);
        HeightMapTextureMaker.WaterGeneration(
            floorPositions, waterMaterial, heightMap, noCaustics, caustic, causticHighlights, seaFoam, shoreLength);
        tilemapVisualizer.PaintWaterTiles(floorPositions);
        
    }

    private void ApplyWaterTexturesToRenderer(
        Renderer rend,
        Texture heightTex,
        Texture noCausticsTex,
        Vector4 gridMin,
        Vector4 gridSize,
        Vector4 tileSize)
    {
        if (!rend) return;

        var mpb = new MaterialPropertyBlock();
        rend.GetPropertyBlock(mpb);

        mpb.SetTexture(Shader.PropertyToID("_HeightTex"),   heightTex);
        mpb.SetTexture(Shader.PropertyToID("_noCaustics"),  noCausticsTex);
        mpb.SetVector (Shader.PropertyToID("_GridMin"),     gridMin);
        mpb.SetVector (Shader.PropertyToID("_GridSize"),    gridSize);
        mpb.SetVector (Shader.PropertyToID("_TileSize"),    tileSize);

        rend.SetPropertyBlock(mpb);
    }


    /// <summary>
    /// Just checks all adjacent tiles to the corridors and adds to them making 3x3.
    /// </summary>
    /// <param name="corridor"></param>
    /// <returns></returns>
    private List<Vector2Int> IncreaseCorridorBrush3by3(List<Vector2Int> corridor)
    {
        List<Vector2Int> newCorridor = new List<Vector2Int>();
        for (int i = 1; i < corridor.Count; i++)
        {
            for (int x = -1; x < 2; x++)
            {
                for (int y = -1; y < 2; y++)
                {
                    newCorridor.Add(corridor[i - 1] + new Vector2Int(x, y));
                }
            }
        }
        return newCorridor;
    }

    private List<Vector2Int> IncreaseCorridorSizeByOne(List<Vector2Int> corridor)
    {
        List<Vector2Int> newCorridor = new List<Vector2Int>();
        Vector2Int previousDirection = Vector2Int.zero;
        for (int i = 1; i < corridor.Count; i++)
        {
            Vector2Int directionFromCell = corridor[i] - corridor[i - 1];
            if (previousDirection != Vector2Int.zero && directionFromCell != previousDirection)
            {
                //handle corner
                for (int x = -1; x < 2; x++)
                {
                    for (int y = -1; y < 2; y++)
                    {
                        newCorridor.Add(corridor[i - 1] + new Vector2Int(x, y));
                    }
                }
                previousDirection = directionFromCell;
            }
            else
            {
                //add a single cell in the direction + 90 degrees
                Vector2Int newCorridorTileOffset = GetDirection90From(directionFromCell);
                newCorridor.Add(corridor[i - 1]);
                newCorridor.Add(corridor[i - 1] + newCorridorTileOffset);
            }
        }
        return newCorridor;
    }

    private Vector2Int GetDirection90From(Vector2Int direction)
    {
        if (direction == Vector2Int.up)
        {
            return Vector2Int.right;
        }
        if (direction == Vector2Int.down)
        {
            return Vector2Int.left;
        }
        if (direction == Vector2Int.right)
        {
            return Vector2Int.down;
        }
        if (direction == Vector2Int.left)
        {
            return Vector2Int.up;
        }
        return Vector2Int.zero;
        
    }
    private void CreateRoomsAtDeadEnd(List<Vector2Int> deadEnds, HashSet<Vector2Int> roomFloors)
    {
        foreach (var position in deadEnds)
        {
            if (roomFloors.Contains(position) == false)
            {
                var room = RunRandomWalk(randomWalkParameters, position);
                roomFloors.UnionWith(room);
                roomMapsDictionairy.Add(position, (HashSet<Vector2Int>)room);
            }
        }
    }

    private List<Vector2Int> FindAllDeadEnds(HashSet<Vector2Int> floorPositions)
    {
        List<Vector2Int> deadEnds = new List<Vector2Int>();
        foreach (var position in floorPositions)
        {
            int neighboursCount = 0; //basically just check if there is one neighbor
            foreach (var direction in Direction2D.cardinalDirectionsList)
            {
                if (floorPositions.Contains(position + direction))
                {
                    neighboursCount++;
                }
            }
            if (neighboursCount == 1)
            {
                deadEnds.Add(position);
            }
        }
        return deadEnds;
    }

    private HashSet<Vector2Int> CreateRooms(HashSet<Vector2Int> potentialRoomPositions)
    {
        HashSet<Vector2Int> roomPositions = new HashSet<Vector2Int>();
        int roomToCreateCount = Mathf.RoundToInt(potentialRoomPositions.Count * roomPercent);
        //List<Vector2Int> roomToCreate = potentialRoomPositions.OrderBy(x => Guid.NewGuid()).Take(roomToCreateCount).ToList();//Randomize which points on the roomPositions list actually generate a room what this line does is it randomly sorts the list by using the unique Guid for each item in the roomPositions hashset then takes the desired number using the take function then converts to a list so we can iterate through each point and create our room
        List<Vector2Int> roomToCreate = potentialRoomPositions.ToList(); //temporary bc the UnityEditor.Rendering is causing build issues
        foreach (var rooms in roomToCreate)
        {
            var roomFloor = RunRandomWalk(randomWalkParameters, rooms); //This is why we made it so this class inherits from simplerandomwalk because we wanted to use runrandomwalk and we wanted to also use the parameters in the randomwalk generator 
            roomPositions.UnionWith(roomFloor);
            roomMapsDictionairy.Add(rooms, roomFloor);
        }
        return roomPositions;
    }

    private List<List<Vector2Int>> CreateCorridors(HashSet<Vector2Int> floorPositions, HashSet<Vector2Int> potentialRoomPositions)
    {
        var currentPosition = startPosition;
        potentialRoomPositions.Add(currentPosition);
        List<List<Vector2Int>> corridors = new List<List<Vector2Int>>();
        for (int i = 0; i < corridorCount; i++)
        {
            var corridor = ProceduralGenerationAlgorithms.RandomWalkCorridor(currentPosition, corridorLength);
            corridors.Add(corridor);
            currentPosition = corridor[corridor.Count - 1];//This is where i comes into play the fact that randomwalkcorridor returns a ordered list we take the last entry and set that as the start point for our next corridor.
            potentialRoomPositions.Add(currentPosition);
            floorPositions.UnionWith(corridor); //union to get rid of dupes.
        }
        corridorPositions = new HashSet<Vector2Int>(corridors.SelectMany(inner => inner));
        return corridors;
    }
}
